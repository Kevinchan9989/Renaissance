<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schema Diff v5 (Smart Types)</title>
    <style>
        /* --- CSS STYLES --- */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; background-color: #f4f4f9; color: #333; }
        
        /* SIDEBAR */
        .sidebar { width: 360px; background-color: #2c3e50; color: white; display: flex; flex-direction: column; border-right: 1px solid #ccc; flex-shrink: 0; }
        .sidebar-header { padding: 15px; background-color: #233140; border-bottom: 1px solid #1a252f; font-weight: bold; text-transform: uppercase; font-size: 13px; }
        .search-box { padding: 10px; background-color: #34495e; }
        .search-box input { width: 100%; padding: 8px; border-radius: 4px; border: none; background-color: #ecf0f1; color: #333; box-sizing: border-box; }
        
        .sidebar-content { flex-grow: 1; overflow-y: auto; }

        /* Sidebar Grouping */
        .schema-block { border-bottom: 1px solid #34495e; }
        .schema-header { padding: 10px 15px; background-color: #2c3e50; cursor: pointer; font-weight: bold; font-size: 12px; color: #ecf0f1; display: flex; justify-content: space-between; align-items: center; user-select: none; }
        .schema-header:hover { background-color: #34495e; }
        .schema-header .arrow { font-size: 10px; transition: transform 0.2s; }
        .schema-header.collapsed .arrow { transform: rotate(-90deg); }
        
        .table-list { list-style: none; padding: 0; margin: 0; background-color: #263544; display: block; }
        .table-list.hidden { display: none; }
        .table-list li { padding: 8px 15px 8px 25px; cursor: pointer; border-bottom: 1px solid #304050; transition: background 0.1s; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
        .table-list li:hover { background-color: #3e5368; }
        .table-list li.active { background-color: #3498db; color: white; font-weight: 600; border-left: 4px solid #fff; }

        /* Flags */
        .flag { font-size: 10px; padding: 2px 6px; border-radius: 4px; font-weight: bold; min-width: 35px; text-align: center; }
        .flag-mod { background-color: #f39c12; color: #fff; } /* Yellow */
        .flag-del { background-color: #e74c3c; color: #fff; } /* Red */
        .flag-add { background-color: #2ecc71; color: #fff; } /* Green */
        .flag-soft { background-color: #27ae60; color: #fff; border: 1px solid #fff; } /* Dark Green */
        .flag-ok { background-color: #95a5a6; color: #fff; opacity: 0.4; } /* Gray */

        /* MAIN AREA */
        .main-container { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        .toolbar { padding: 0 20px; background-color: #fff; border-bottom: 1px solid #ddd; display: flex; align-items: center; height: 50px; gap: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .tab-btn { padding: 15px 10px; border: none; background: transparent; cursor: pointer; font-size: 14px; font-weight: 600; color: #777; border-bottom: 3px solid transparent; transition: all 0.2s; }
        .tab-btn:hover { color: #333; }
        .tab-btn.active { color: #007bff; border-bottom-color: #007bff; }
        .run-btn { margin-left: auto; padding: 8px 20px; background-color: #28a745; color: white; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; }

        .panel { display: none; flex-grow: 1; overflow: hidden; }
        .panel.active { display: flex; }

        #inputPanel { height: 100%; }
        .input-box { flex: 1; display: flex; flex-direction: column; padding: 15px; border-right: 1px solid #eee; }
        .input-box textarea { flex: 1; font-family: Consolas, monospace; font-size: 12px; padding: 15px; resize: none; border: 1px solid #ccc; border-radius: 4px; background-color: #fafafa; white-space: pre; overflow: auto; }
        .input-label { font-weight: bold; margin-bottom: 10px; color: #2c3e50; font-size: 12px; }

        #resultPanel { flex-direction: column; padding: 30px; overflow-y: auto; background-color: #fff; }
        
        /* DIFF TABLES */
        .comp-table { width: 100%; border-collapse: collapse; margin-bottom: 30px; font-family: Calibri, sans-serif; font-size: 14px; table-layout: fixed; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .comp-table th, .comp-table td { border: 1px solid #e0e0e0; padding: 8px 12px; vertical-align: top; text-align: left; word-wrap: break-word; }
        .comp-table th { background-color: #f8f9fa; color: #333; font-weight: bold; border-bottom: 2px solid #ddd; }
        
        .row-mod { background-color: #fff8e1; } /* Yellow - Hard Diff */
        .row-soft { background-color: #e8f5e9; color: #2e7d32; } /* Green - Soft Match */
        .row-miss { background-color: #fbe9eb; color: #c0392b; opacity: 0.8; }
        .row-add { background-color: #eafaf1; color: #27ae60; }
        
        .diff-val { color: #d35400; font-weight: bold; background: #ffe082; padding: 0 4px; border-radius: 3px; }
        .soft-val { text-decoration: underline; text-decoration-style: dotted; font-weight: bold; }

        .badge { display: inline-block; padding: 2px 5px; font-size: 10px; border-radius: 3px; color: white; margin-right: 5px; }
        .badge-pk { background-color: #c0392b; }
        
        .code { font-family: Consolas, monospace; color: #444; }
        .note { font-size: 11px; font-style: italic; color: #666; }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="sidebar-header">Schema Diff 5.0</div>
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Search tables..." onkeyup="filterList()">
        </div>
        <div id="sidebarContent" class="sidebar-content"></div>
    </div>

    <div class="main-container">
        <div class="toolbar">
            <button class="tab-btn active" id="tabInput" onclick="switchTab('input')">1. Input DDL/DBML</button>
            <button class="tab-btn" id="tabResult" onclick="switchTab('result')">2. Comparison Results</button>
            <button class="run-btn" onclick="runCompare()">Run Compare &#9654;</button>
        </div>

        <div id="inputPanel" class="panel active">
            <div class="input-box">
                <div class="input-label">SOURCE (Left)</div>
                <textarea id="sourceInput" placeholder="Paste Source SQL DDL..."></textarea>
            </div>
            <div class="input-box">
                <div class="input-label">TARGET (Right)</div>
                <textarea id="targetInput" placeholder="Paste Target DDL or DBML..."></textarea>
            </div>
        </div>

        <div id="resultPanel" class="panel">
            <div style="text-align:center; color:#999; margin-top:100px;">
                <h3>Ready to Compare</h3>
                <p>Paste data in Tab 1 and click <strong>Run Compare</strong>.</p>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. UI & PARSER UTILS
        // ==========================================
        function switchTab(tabName) {
            document.getElementById('tabInput').className = tabName === 'input' ? 'tab-btn active' : 'tab-btn';
            document.getElementById('tabResult').className = tabName === 'result' ? 'tab-btn active' : 'tab-btn';
            document.getElementById('inputPanel').className = tabName === 'input' ? 'panel active' : 'panel';
            document.getElementById('resultPanel').className = tabName === 'result' ? 'panel active' : 'panel';
        }

        function toggleSchema(block) {
            const ul = block.querySelector('ul');
            const header = block.querySelector('.schema-header');
            ul.classList.toggle('hidden');
            header.classList.toggle('collapsed');
        }

        // Helper to normalize types during parsing
        // This solves BPCHAR vs CHAR issue immediately
        function normalizeType(t) {
            t = t.trim().toUpperCase();
            
            // 1. Remove internal spaces: CHAR ( 1 ) -> CHAR(1)
            t = t.replace(/\s+/g, '');

            // 2. Postgres Conversions
            // Replace BPCHAR with CHAR globally (at start)
            if (t.startsWith('BPCHAR')) {
                t = t.replace('BPCHAR', 'CHAR');
            }
            if (t.startsWith('INT8')) t = 'BIGINT';
            if (t.startsWith('INT4')) t = 'INTEGER';
            if (t.startsWith('FLOAT8')) t = 'DOUBLEPRECISION';

            return t;
        }

        // ==========================================
        // 2. PARSERS (SQL & DBML)
        // ==========================================

        function parseSchema(text) {
            if (text.match(/^\s*Table\s+\w+/m)) return parseDBML(text);
            return parseSQL(text);
        }

        function parseSQL(text) {
            const tables = {};
            text = text.replace(/\/\*[\s\S]*?\*\//g, '').replace(/--.*$/gm, ''); // No comments
            const tableRegex = /CREATE\s+TABLE\s+(?:["`\[]?(\w+)["`\]]?\.)?["`\[]?(\w+)["`\]]?\s*\(([\s\S]+?)\)\s*;/gi;
            
            let match;
            while ((match = tableRegex.exec(text)) !== null) {
                const schema = match[1] || '(Default)';
                const tableName = match[2];
                const content = match[3];
                const key = tableName.toUpperCase();
                
                const cols = {};
                const pks = new Set();
                const lines = splitSqlContent(content);

                lines.forEach(line => {
                    line = line.trim();
                    if (!line) return;
                    const upperLine = line.toUpperCase();
                    
                    // PK Constraint
                    if (upperLine.startsWith('CONSTRAINT') || upperLine.startsWith('PRIMARY KEY')) {
                        if (upperLine.includes('PRIMARY KEY')) {
                            const pkMatch = line.match(/\(([^)]+)\)/);
                            if (pkMatch) pkMatch[1].split(',').forEach(c => pks.add(cleanName(c)));
                        }
                        return;
                    }

                    // Column
                    const colMatch = line.match(/^["`\[]?(\w+)["`\]]?\s+(.+)$/);
                    if (colMatch) {
                        const colName = colMatch[1].toUpperCase();
                        let def = colMatch[2];
                        
                        // Capture type aggressively until space or comma/paren end
                        // Regex looks for words, parens, numbers
                        let typeMatch = def.match(/^([a-zA-Z0-9_]+(?:\([0-9,\s]+\))?)/);
                        if (typeMatch) {
                            let colType = normalizeType(typeMatch[1]);
                            cols[colName] = { name: colName, type: colType, nullable: !def.toUpperCase().includes('NOT NULL') };
                            if (def.toUpperCase().includes('PRIMARY KEY')) pks.add(colName);
                        }
                    }
                });
                tables[key] = { name: tableName, schema: schema, fullName: (schema !== '(Default)' ? schema + '.' : '') + tableName, columns: cols, pks: Array.from(pks) };
            }
            return tables;
        }

        function parseDBML(text) {
            const tables = {};
            text = text.replace(/\/\/.*$/gm, '');
            const tableRegex = /Table\s+(?:["`]?(\w+)["`]?\.)?["`]?(\w+)["`]?\s*\{([\s\S]*?)\}/gi;
            
            let match;
            while ((match = tableRegex.exec(text)) !== null) {
                const schema = match[1] || '(Default)';
                const tableName = match[2];
                const content = match[3];
                const key = tableName.toUpperCase();
                const cols = {};
                const pks = new Set();
                const lines = content.split('\n');
                
                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('Note:')) return;
                    
                    // DBML Column
                    const colMatch = line.match(/^["`]?(\w+)["`]?\s+(.+?)(\s*\[.*\])?$/);
                    if (colMatch) {
                        const colName = colMatch[1].toUpperCase();
                        let colType = normalizeType(colMatch[2]);
                        const settings = (colMatch[3] || '').toLowerCase();
                        
                        cols[colName] = { name: colName, type: colType, nullable: !settings.includes('not null') };
                        if (settings.includes('pk')) pks.add(colName);
                    }
                });
                tables[key] = { name: tableName, schema: schema, fullName: tableName, columns: cols, pks: Array.from(pks) };
            }
            return tables;
        }

        function splitSqlContent(str) {
            const result = []; let current = ''; let parenLevel = 0;
            for (let i = 0; i < str.length; i++) {
                const c = str[i];
                if (c === '(') parenLevel++; if (c === ')') parenLevel--;
                if (c === ',' && parenLevel === 0) { result.push(current); current = ''; } else { current += c; }
            }
            if (current.trim()) result.push(current);
            return result;
        }
        function cleanName(str) { return str.trim().replace(/["`\[\]]/g, '').toUpperCase(); }

        // ==========================================
        // 3. COMPARISON LOGIC (Soft Match Engine)
        // ==========================================

        let diffResults = {};

        function runCompare() {
            const srcText = document.getElementById('sourceInput').value;
            const tgtText = document.getElementById('targetInput').value;
            if(!srcText && !tgtText) { alert("Please input schemas."); return; }

            const srcTables = parseSchema(srcText);
            const tgtTables = parseSchema(tgtText);
            diffResults = {};

            // Compare
            Object.keys(srcTables).forEach(key => {
                const sTbl = srcTables[key];
                const tTbl = tgtTables[key];
                if (!tTbl) {
                    diffResults[key] = { status: 'MISSING', src: sTbl, tgt: null };
                } else {
                    const diff = compareColumns(sTbl, tTbl);
                    let status = 'IDENTICAL';
                    if (diff.hasHardDiff) status = 'MODIFIED'; // Yellow/Red
                    else if (diff.hasSoftDiff) status = 'SOFT_MATCH'; // Green/Safe
                    
                    diffResults[key] = { status: status, src: sTbl, tgt: tTbl, details: diff };
                }
            });

            Object.keys(tgtTables).forEach(key => {
                if (!srcTables[key]) diffResults[key] = { status: 'ADDED', src: null, tgt: tgtTables[key] };
            });

            renderSidebar();
            switchTab('result');
            document.getElementById('resultPanel').innerHTML = `<div style="text-align:center;margin-top:50px;color:#555;"><h2>Comparison Complete</h2><p>Select a table to view details.</p></div>`;
        }

        function compareColumns(s, t) {
            const changes = [];
            let hasHardDiff = false;
            let hasSoftDiff = false;

            const sPk = s.pks.sort().join(',');
            const tPk = t.pks.sort().join(',');
            const pkDiff = (sPk !== tPk);
            if(pkDiff) hasHardDiff = true;

            const allCols = new Set([...Object.keys(s.columns), ...Object.keys(t.columns)]);

            allCols.forEach(colName => {
                const sCol = s.columns[colName];
                const tCol = t.columns[colName];

                if (!sCol) {
                    changes.push({ col: colName, type: 'ADDED', s: null, t: tCol });
                    hasHardDiff = true;
                } else if (!tCol) {
                    changes.push({ col: colName, type: 'DELETED', s: sCol, t: null });
                    hasHardDiff = true;
                } else {
                    // Type Check
                    const check = checkTypes(sCol.type, tCol.type);
                    const nullMatch = (sCol.nullable === tCol.nullable);

                    if (!nullMatch) {
                        changes.push({ col: colName, type: 'MODIFIED', s: sCol, t: tCol, note: 'Nullable changed' });
                        hasHardDiff = true;
                    } 
                    else if (check.match) {
                        if (check.soft) {
                            changes.push({ col: colName, type: 'SOFT', s: sCol, t: tCol, note: check.reason });
                            hasSoftDiff = true;
                        } else {
                            changes.push({ col: colName, type: 'SAME', s: sCol, t: tCol });
                        }
                    } else {
                        changes.push({ col: colName, type: 'MODIFIED', s: sCol, t: tCol });
                        hasHardDiff = true;
                    }
                }
            });
            return { hasHardDiff, hasSoftDiff, pkDiff, changes };
        }

        function checkTypes(t1, t2) {
            if (t1 === t2) return { match: true, soft: false };

            // 1. VARCHAR compatibility
            if ((t1 === 'VARCHAR' && t2 === 'VARCHAR2') || (t1 === 'VARCHAR2' && t2 === 'VARCHAR')) {
                return { match: true, soft: true, reason: "VARCHAR ≈ VARCHAR2" };
            }

            // 2. NUMERIC(X) vs NUMERIC(X,0)
            if (t1.startsWith('NUMERIC') && t2.startsWith('NUMERIC')) {
                const p1 = getNumericParams(t1);
                const p2 = getNumericParams(t2);
                if (p1[0] === p2[0] && p1[1] === p2[1]) {
                    return { match: true, soft: true, reason: `Ignored: Scale (0)` };
                }
            }

            return { match: false };
        }

        // Helper: NUMERIC(20) -> [20, 0]
        function getNumericParams(typeStr) {
            const match = typeStr.match(/\(([0-9,]+)\)/);
            if (!match) return [0, 0]; // Plain NUMERIC
            const parts = match[1].split(',');
            const p = parseInt(parts[0]);
            const s = parts.length > 1 ? parseInt(parts[1]) : 0; // Default scale 0
            return [p, s];
        }

        // ==========================================
        // 4. RENDERING
        // ==========================================

        function renderSidebar() {
            const container = document.getElementById('sidebarContent');
            container.innerHTML = '';

            const groups = {};
            Object.keys(diffResults).sort().forEach(key => {
                const res = diffResults[key];
                const schema = (res.src ? res.src.schema : res.tgt.schema) || '(Default)';
                if(!groups[schema]) groups[schema] = [];
                groups[schema].push({ key, res });
            });

            Object.keys(groups).sort().forEach(schema => {
                const block = document.createElement('div');
                block.className = 'schema-block';
                block.dataset.schemaName = schema.toLowerCase();

                const header = document.createElement('div');
                header.className = 'schema-header';
                header.innerHTML = `<span>${schema}</span> <span class="arrow">▼</span>`;
                header.onclick = () => toggleSchema(block);

                const ul = document.createElement('ul');
                ul.className = 'table-list';

                groups[schema].forEach(item => {
                    const li = document.createElement('li');
                    li.dataset.name = item.key.toLowerCase();
                    li.onclick = (e) => { e.stopPropagation(); loadDetail(item.key); };

                    let badge = '';
                    const s = item.res.status;
                    if(s === 'MISSING') badge = '<span class="flag flag-del">Del</span>';
                    else if(s === 'ADDED') badge = '<span class="flag flag-add">New</span>';
                    else if(s === 'MODIFIED') badge = '<span class="flag flag-mod">Mod</span>';
                    else if(s === 'SOFT_MATCH') badge = '<span class="flag flag-soft">Soft</span>';
                    else badge = '<span class="flag flag-ok">Ok</span>';

                    li.innerHTML = `<span>${item.res.src ? item.res.src.name : item.res.tgt.name}</span> ${badge}`;
                    ul.appendChild(li);
                });

                block.appendChild(header);
                block.appendChild(ul);
                container.appendChild(block);
            });
        }

        function loadDetail(key) {
            document.querySelectorAll('.table-list li').forEach(l => l.classList.remove('active'));
            const res = diffResults[key];
            const panel = document.getElementById('resultPanel');
            let html = `<h2>${key}</h2>`;

            if (res.status === 'IDENTICAL') {
                html += `<div style="padding:10px; background:#e2e3e5; margin-bottom:20px; border-radius:4px;">Tables are identical.</div>`;
                html += renderStruct(res.src, 'Source Structure');
            } else if (res.status === 'MISSING') {
                html += `<div style="padding:10px; background:#fbe9eb; color:#c0392b; margin-bottom:20px; border-radius:4px;">Table deleted in Target.</div>`;
                html += renderStruct(res.src, 'Source (Deleted)');
            } else if (res.status === 'ADDED') {
                html += `<div style="padding:10px; background:#eafaf1; color:#27ae60; margin-bottom:20px; border-radius:4px;">Table added in Target.</div>`;
                html += renderStruct(res.tgt, 'Target (New)');
            } else {
                // MODIFIED or SOFT MATCH
                if(res.details.pkDiff) {
                    html += `<div style="padding:10px; background:#fff3cd; color:#856404; margin-bottom:10px; border-radius:4px;">
                        <strong>PK Mismatch:</strong> Source[${res.src.pks}] vs Target[${res.tgt.pks}]
                    </div>`;
                }
                html += `<table class="comp-table"><thead><tr>
                    <th width="20%">Column</th><th width="30%">Source</th><th width="30%">Target</th><th width="20%">Notes</th>
                </tr></thead><tbody>`;
                
                res.details.changes.forEach(row => {
                    let rClass = '';
                    let note = row.note || '';
                    let sHtml = '', tHtml = '';

                    if(row.type === 'SAME') {
                        sHtml = fmtCol(row.s, res.src.pks);
                        tHtml = fmtCol(row.t, res.tgt.pks);
                    } else if(row.type === 'SOFT') {
                        rClass = 'row-soft';
                        sHtml = `<span class="soft-val">${fmtCol(row.s, res.src.pks)}</span>`;
                        tHtml = `<span class="soft-val">${fmtCol(row.t, res.tgt.pks)}</span>`;
                    } else if(row.type === 'DELETED') {
                        rClass = 'row-miss';
                        sHtml = fmtCol(row.s, res.src.pks); tHtml = '<em>Missing</em>';
                    } else if(row.type === 'ADDED') {
                        rClass = 'row-add';
                        sHtml = '<em>Missing</em>'; tHtml = fmtCol(row.t, res.tgt.pks);
                    } else {
                        rClass = 'row-mod';
                        sHtml = diffVal(row.s, row.t, res.src.pks);
                        tHtml = diffVal(row.t, row.s, res.tgt.pks);
                    }

                    html += `<tr class="${rClass}"><td class="code"><strong>${row.col}</strong></td><td>${sHtml}</td><td>${tHtml}</td><td class="note">${note}</td></tr>`;
                });
                html += '</tbody></table>';
            }
            panel.innerHTML = html;
        }

        function renderStruct(tbl, title) {
            let h = `<h4>${title}</h4><table class="comp-table"><thead><tr><th>Column</th><th>Type</th><th>Nullable</th></tr></thead><tbody>`;
            Object.values(tbl.columns).forEach(c => {
                let pk = tbl.pks.includes(c.name) ? '<span class="badge badge-pk">PK</span>' : '';
                h += `<tr><td class="code">${c.name} ${pk}</td><td>${c.type}</td><td>${c.nullable}</td></tr>`;
            });
            h += '</tbody></table>';
            return h;
        }

        function fmtCol(c, pks) {
            if(!c) return '';
            let pk = pks.includes(c.name) ? '<span class="badge badge-pk">PK</span>' : '';
            return `${pk} ${c.type} <small>${c.nullable ? 'NULL' : 'NOT NULL'}</small>`;
        }

        function diffVal(c1, c2, pks) {
            let pk = pks.includes(c1.name) ? '<span class="badge badge-pk">PK</span>' : '';
            let typeStyle = (c1.type !== c2.type) ? 'class="diff-val"' : '';
            let nullStyle = (c1.nullable !== c2.nullable) ? 'class="diff-val"' : '';
            return `${pk} <span ${typeStyle}>${c1.type}</span> <small ${nullStyle}>${c1.nullable ? 'NULL' : 'NOT NULL'}</small>`;
        }

        function filterList() {
            const term = document.getElementById('searchInput').value.toLowerCase();
            const blocks = document.querySelectorAll('.schema-block');
            blocks.forEach(block => {
                let hasVisible = false;
                block.querySelectorAll('li').forEach(li => {
                    if(li.dataset.name.includes(term) || block.dataset.schemaName.includes(term)) {
                        li.style.display = 'flex'; hasVisible = true;
                    } else { li.style.display = 'none'; }
                });
                block.style.display = hasVisible ? 'block' : 'none';
            });
        }
    </script>
</body>
</html>