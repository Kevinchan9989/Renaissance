// Test parsing the FULL SQL you provided

const fullSQL = `
CREATE TABLE iss.iss_announcement_allotment_params (
	id int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 150000000000001 CACHE 1 NO CYCLE),
	"uuid" varchar(36) NOT NULL DEFAULT gen_random_uuid(),
	iss_sec_params_uuid varchar(36) NOT NULL,
	coupon_rate_desc varchar(100) NULL,
	yield_price_desc varchar(100) NULL,
	comp_app_desc varchar(200) NULL,
	noncomp_app_desc varchar(200) NULL,
	eligible_applicants_desc varchar(100) NULL,
	footnote_new varchar(4000) NULL,
	footnote_reopen varchar(4000) NULL,
	comp_bids_enabled_flag bpchar(1) NOT NULL,
	noncomp_bids_enabled_flag bpchar(1) NOT NULL,
	interfacing_enabled_flag bpchar(1) NOT NULL,
	method_of_sale varchar(50) NOT NULL,
	sof_cash_flag bpchar(1) NOT NULL,
	sof_cpfis_flag bpchar(1) NOT NULL,
	sof_cpfoa_flag bpchar(1) NOT NULL,
	sof_srs_flag bpchar(1) NOT NULL,
	ai_retail_flag bpchar(1) NOT NULL,
	ai_institutional_flag bpchar(1) NOT NULL,
	limits_enabled_flag bpchar(1) NOT NULL,
	safeguards_enabled_flag bpchar(1) NOT NULL,
	underbid_check_enabled_flag bpchar(1) NOT NULL,
	accept_negative_yield_flag bpchar(1) NOT NULL,
	coupon_pymt_frequency varchar(50) NULL,
	limit_per_issue_pd_pct numeric(5, 2) NOT NULL DEFAULT 0,
	limit_per_issue_nonpd_pct numeric(5, 2) NOT NULL DEFAULT 0,
	ind_noncomp_limit_pd_pct numeric(5, 2) NOT NULL DEFAULT 0,
	ind_noncomp_limit_nonpd_amt numeric(20) NOT NULL DEFAULT 0,
	overall_issuance_noncomp_lmt numeric(5, 2) NOT NULL DEFAULT 0,
	lower_upper_bound_offset_bps numeric(5) NOT NULL DEFAULT 0,
	underbid_insert_pctile numeric(3) NOT NULL DEFAULT 0,
	applicable_pds varchar(36) NULL,
	status varchar(20) NOT NULL,
	"version" numeric(5) NOT NULL DEFAULT 1,
	is_deleted bpchar(1) NOT NULL DEFAULT 'N'::bpchar,
	is_migrated bpchar(1) NOT NULL DEFAULT 'N'::bpchar,
	created_dt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	created_by varchar(36) NOT NULL,
	updated_dt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	updated_by varchar(36) NOT NULL,
	CONSTRAINT iss_ann_allot_params_pkey PRIMARY KEY (id),
	CONSTRAINT iss_ann_allot_params_uuid_key UNIQUE (uuid),
	CONSTRAINT fk_annparams_secparams FOREIGN KEY (iss_sec_params_uuid) REFERENCES iss.iss_sec_params("uuid")
);
`;

// splitSqlParams function
function splitSqlParams(txt) {
  const result = [];
  let buffer = '';
  let depth = 0;

  for (let i = 0; i < txt.length; i++) {
    const char = txt[i];
    if (char === '(') depth++;
    else if (char === ')') depth--;

    if (char === ',' && depth === 0) {
      result.push(buffer);
      buffer = '';
    } else {
      buffer += char;
    }
  }

  if (buffer.trim()) result.push(buffer);
  return result;
}

function cleanName(str) {
  return str ? str.replace(/["`\[\]]/g, '').trim() : '';
}

// Extract table body
const createRegex = /CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(?:["`]?(\w+)["`]?\.)?["`]?(\w+)["`]?\s*\(([\s\S]*?)\)\s*;/gi;
const match = createRegex.exec(fullSQL);

if (match) {
  const schema = match[1] || 'public';
  const tableName = match[2];
  const body = match[3];

  console.log('Table:', `${schema}.${tableName}`);
  console.log('\n=== Parsing body ===\n');

  const lines = splitSqlParams(body);
  console.log('Total lines/params:', lines.length);

  let constraintCount = 0;
  let columnCount = 0;
  let fkCount = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const upperLine = line.toUpperCase();

    if (upperLine.startsWith('CONSTRAINT') || upperLine.startsWith('PRIMARY') || upperLine.startsWith('FOREIGN') || upperLine.startsWith('UNIQUE')) {
      constraintCount++;
      console.log(`\nLine ${i} [CONSTRAINT]:`);
      console.log(line.substring(0, 100));

      if (upperLine.includes('FOREIGN KEY')) {
        fkCount++;
        const fkRegex = /(?:CONSTRAINT\s+(\w+)\s+)?FOREIGN\s+KEY\s*\(([^)]+)\)\s*REFERENCES\s+(?:["`]?(\w+)["`]?\.)?["`]?(\w+)["`]?\s*\(([^)]+)\)/i;
        const fkMatch = line.match(fkRegex);
        if (fkMatch) {
          const constraintName = fkMatch[1] || `fk_${tableName}`;
          const localCols = fkMatch[2].split(',').map(c => cleanName(c)).join(', ');
          const refSchema = fkMatch[3] || 'public';
          const refTable = fkMatch[4];
          const refCols = fkMatch[5].split(',').map(c => cleanName(c)).join(', ');
          const refString = `${refSchema}.${refTable}(${refCols})`;

          console.log('  ✅ FK PARSED:');
          console.log('    Name:', constraintName);
          console.log('    Local:', localCols);
          console.log('    Ref:', refString);
        } else {
          console.log('  ❌ FK NOT MATCHED');
        }
      }
    } else if (!upperLine.startsWith('CHECK')) {
      columnCount++;
    }
  }

  console.log('\n=== Summary ===');
  console.log('Columns:', columnCount);
  console.log('Constraints:', constraintCount);
  console.log('Foreign Keys:', fkCount);
} else {
  console.log('❌ Failed to match CREATE TABLE');
}
